    CHAPTER 1: Introduction to Programming
-------------------------------------------------------
Fill in the blanks
1.  Computer Software
2.  software
3.  programming
4.  Programming language
5.  Driver Software
6.  Operating System (OS)
7.  System Software
8.  System software
9.  Cryptographic utilities
10. a label, an operation code and one or more operands
--------------------------------------------------------
Multiple Choice Questions
1.  b
2.  d
3.  c
4.  d
5.  a
6.  d
7.  b
8.  c
9.  b
10. a
--------------------------------------------------------
State True or False
1.  T
2.  T
3.  T
4.  F Word processor is an example of productivity software
5.  F Desktop publishing system is an application software
6.  F
7.  T
8.  T
9.  F label is used to identify and reference instructions in the program (Assembly Programming Language)
10. T
----------------------------------------------------------
Review Questions
1. Broadly classify the computer system into two parts. Also make a comparison between a human body and the computer system thereby
   explaining what each part does.
Answer:           COMPUTER SYSTEM
                       |
             _______________________
            |                       |
    COMPUTER HARDWARE       COMPUTER SOFTWARE
                                    |
                          ______________________
                         |                      |
                     SYSTEM SOFTWARE         APPLICATION SOFTWARE

Computer system consists of two parts:
1. Computer Hardware: does all the pysical work computers are known for.
2. Computer Software: commands the hardare what to do and how to do.
Analogy:
If computer is considered as a living being, then the hardware would be the body that does all the things like seeing wwith eyes,
lifting objects and filling lungs with air. The softare would be the intelligence which helps in the interpertation of the images that are seen by eyes, ionstructing arms how to lift an object.
Hardware is the pysical body and software is the brain and nervous system which commands the physical body to perform meaningful tasks

2. Differentiate between computer hardware and software.
Answer:
              HARDWARE                      |     SOFTWARE
1. It is the physical and visibile component| It is a set oof instructions which enables 
   of the computer system such as monitor,  | hardware to perform specific tasks
   CPU keyboard, mouse                      |
2. It does all the pysical work computers   | It commands the hardare what to do and how  
   are known for                            | to do
3. It can not be used to analyse given set  | It instructs hardware to how to analyse data
   of data and find a solution of its own   | data and find solution

3. Define programming.
Answer: A program is a set of instructions that is arranged in a sequence to guide a computer to find a solution for the given problem.
        The process of writing a program is called programming

4. Define source code.
Answer: The programmers write a set of instructions (program) using a specific programming language. Such instructions are known as 
        source code.

5. What is booting?
Answer: When a computer is switched on / starts, the code in BIOS chips run a series of tests called POST (Power On Self Test) to
        ensure that the system devices are working correctly. Then BIOS locates software held on a peripherical devices such as a 
        hard disk or a CD, and loads and executes that software, giving the control to computer. This process is known as booting.

6 What criteria is used to select the language in which the program will be written?
Answer: Criteria used are:
1. The type of computer on which the program has to be executed
2. The type of program
3. The expertise of the programmer

7. Explain the role of operating system.
Answer: The primary goal of an operating system is to make the computer system (or any other device in which it is installed like cell
        phones) convenient and efficient to use. The operating system offers generic services to support user applications. It ensures 
        that system resources like keyboard/mouse, all the complex details of character reading program are hidden from user or simply
        provide a layer of abstraction so that user can work efficiently without bothering about underlying details. It ensure system 
        resources like CPU, memory, I/O devices are utilized efficiently. It has a control policy and algorithm to allocate user 
        resources.It coordinates system resources and allows execution of other programs (Application software)

8. Give some examples of computer software.
Answer: some examples are:
1. Entertainement: computer games, media player such as VLC studio
2. Driver software: to interact with additional peripherical devices such as printer, scanner,video card, web camera
3. Educational software: which helps in teaching and learning
4. Productivity softare: excel or spreadsheet software, database management utilities, presentation softares
5. Operating System: such as Windows, MacOS whichcoordinates system resources and allows execution of other programs

9. Differentiate between the source code and the object code.
Answer:                                     SOURCE CODE                         OBJECT CODE
1. Generation of Code:         By a programmer/ human genrated      | generated by a compiler or interpreter or any other 
                                                                    | translator (machine generated)
2. Level of Code:              high level type                      | low level type
3. Code language:              high level programming language      | binary language
4. Understanable wasily by:    Humans                               | Machine
5. Ease of modification:       easily modify                        | cannot modify
6. Comments:                   can have comments by programmer      | lacks any kind of comments for machine to understand
7. Number of statement:        less as compared to object           | more as compared to source code
   code                                                             |
8. Perforamance of code:       performs way less as not             | performs more and better as very close to machien
   closer to machine                                                |
9. Relationship with assembler                                      |
   compiler, translator:       act as the input                     | act as the output

    
10. Why are compilers and interpreters used?
Answer: They are used to transform high level type code or source code written in a programming language into a machine language which is
        binary (1's and 0's) called object code. Thererfore they are used to translate source code from a high level language to a lower
        level language (e.g assembly language or machine code)

11. Is there any difference between a compiler and an interpreter?
Answer: 
                Compiler                                  |                	Interpreter                                                                                                             
1. Steps of Programming:                                  |
                                                          |
Program Creation.                                         | Steps of Programming:
Analysis of language by the compiler and throws           | Program Creation.
  errors in case of any incorrect statement.              | Linking of files or generation of Machine Code is not required by Interpreter.
In case of no error, the Compiler converts the            | Execution of source statements one by one.
  source code to Machine Code.                            |
Linking of various code files into a runnable             |
  program.                                                |
Finally runs a Program.                                   |
                                                          |
2.The compiler saves the Machine Language in form of      | The Interpreter does not save the Machine Language. 
 Machine Code on disks.                                   |
                                                          |
3. Compiled codes run faster than Interpreter.            | Interpreted codes run slower than Compiler.
                                                          |
4. Linking-Loading Model is the basic working model of    | The Interpretation Model is the basic working model of the Interpreter.
   the Compiler.                                          |
                                                          |
5. The compiler generates an output in the form of (.exe).| The interpreter does not generate any output.
                                                          |
6. Any change in the source program after the compilation | Any change in the source program during the translation does not require           
   requires recompiling the entire code.                  |  retranslation of the entire code.

7.Errors are displayed in Compiler after Compiling        | Errors are displayed in every single line.
  together at the current time.                           |

Some other points to be considered
1. The compiler can see code upfront which helps in running the code faster because of performing Optimization.
   The Interpreter works by line working of Code, thatâ€™s why Optimization is a little slower compared to Compilers.

2. Compiler: It does not require source code for later execution. 
   Interpreter: It requires source code for later execution.

3. Compiler: Execution of the program takes place only after the whole program is compiled.
   Interpreter: Execution of the program happens after every line is checked or evaluated.

4. Compiler: Compilers more often take a large amount of time for analyzing the source code.
   Interpreter: In comparison, Interpreters take less time for analyzing the source code.

5. Compiler: CPU utilization is more in the case of a Compiler.
   Interpreter: CPU utilization is less in the case of a Interpreter.

6. Compiler: The use of Compilers mostly happens in Production Environment.
   Interpreter: The use of Interpreters is mostly in Programming and Development Environments.

7. Compiler: Object code is permanently saved for future use.
   Interpreter: No object code is saved for future use.

8. Compiler: C, C++, C#, etc are programming languages that are compiler-based.
   Interpreter: Python, Ruby, Perl, SNOBOL, MATLAB, etc are programming languages that are interpreter-based.

12. What is application software? Give examples
Answer: Application software is designed to solve particular pROBLEM FOR USERS. It is a type of computer software that employs the 
        capabilitie of a computer to perform user-defined tasks. It represents programsthat allow users to do something beside
        simply run the hardware. Examples: spreadsheets, database system, games, web browser, IDE, etc.

13. What is BIOS?
Answer: BIOS (Basic Input/Output system) is a de facto standards defining a firmware interface. It is built into computer and is the 
        first code run by computer when switched on. The key role of BIO is to load and start operating system. It also provides
        basic functionality to operate and control the hardware connected to or built into computer. 

14. What do you understand by utility software? Is it a must to have it?
Answer: Utility Softare is used to analyse, configure, optimize, and maintain the computer system. It may be requested by Application
        programs during exection for multiple purposes. Yes it is must to have it. It performs very important functions such as disk
        fragments (detect files whose content are broken across several locations and move to one location to increse efficiency), disk
        checker, cleaner, analyserm compression and much more.

15. Differentiate between syntax errors and logical errors.
Answer: If the source code contains errors then the compiler will not be able to perform its intended task. Errors that limit the compiler
        in understanding a program are called syntax errors. Syntax errors may be spelling mistakes, typing mistakes, etc. Another type of
        error is logical error which occurs when the program does not function accurately. Logical errors are much harder to locate and
        correct.
                            Syntax Errors	    |   Logical Errors
   1. Syntax Errors occur when we violate the rules | Logical Errors occur due to our mistakes in programming logic.
      of writing the statements of the programming  |
      language.	                                    |
   2. Program fails to compile and execute.	    | Program compiles and executes but doesn't give the desired output.
   3. Syntax Errors are caught by the compiler.	    | Logic errors need to be found and corrected by the people working on the program.

The work of a compiler is simply to translate human readable source code into computer executable machine code. It can locate syntax errors in the program (if any) but cannot fix it. Until and unless the syntactical error is rectified the source code cannot be converted into the

object code.

16. Can a program written in a high-level language be execute-without a linker?
Answer:  No
         Compiling (without linking) generally cannot create an executable because most programs rely on other pre-compiled programs
         provided by the language For example, if your program takes a square root of a number, your program will rely on the mathematical
         program (provided by the math library of the language) that actually determines how to compute a square root. When you start
         writing bigger programs, you will likely link to other programs that you, yourself, have written.
         The job of the linker is to associate the program you've compiled with other programs that have already been compiled.  Object
         code isn't easily read by humans but it cannot be correctly understood by a computer.  The linker takes your object code, along
         with any other object code files (that your program requires) and links them together to create an executable.  You shouldn't
         expect to find link errors until you're writing larger programs that have multiple parts; link errors  occur when the object
         files for your program don't completely agree.

17. Give a brief description of generation of programming languages. Highlight the advantages and disadvantages of languages in each
    generation.
Answer: A programming language is a language specifically designed to express computations that can be performed by the computer.
        Programming languages are used to create programs that control the behaviour of a system, to express algorithms, or as a mode of
        human-computer communication
        The concept of generations of programming languages (also known as levels), is closely connected to the advances in technology
        that brought about computer generations. The four generations of programming languages include:
        1. machine language
        2. assembly language
        3. high-level language (also known as third generation language or 3GL)
        4. very high-level language (also known as fourth generation language or 4GL).
1. First Generation:
Machine language was used to program the first stored program on computer systems. This is the lowest level of programming language. The machine language is the only language that the computer understands. All the commands and data values are expressed using 1 and 0s, corresponding to the 'on' and 'off' electrical states in a computer.
However, on the down side, the machine language is difficult to learn and is far more difficult to edit if errors occur. Moreover, if you want to add some instructions into memory at some location, then all the instructions after the insertion point would have to be moved down to make room in memory to accommodate the new instructions.
Last but not the least, the code written in machine language is not portable across systems and to transfer the code to a different computer it needs to be completely rewritten since the machine language for one computer could be significantly different from another computer Architectural considerations made portability a tough issue to resolve.

2. Second Generation
The second generation of programming language includes the assembly language. Assembly languages are symbolic programming languages that use symbolic notation to represent machine-language instructions. These languages are closely connected to machine language and the internal architecture of the computer system on which they are used. Since they are close to the machine, assembly language is also called low-level language
Assembly language programs consist of a series of individual statements or instructions that instruct the computer what to do. Basically, an assembly language statement consists of a label, an operation code, and one or more operands Labels are used to identify and reference instructions in the program. The operation code (opcode) is a mnemonic that specifies the operation that has to be performed such as move, add, subtract, or compare. The operand specifies the register or the location in main memory from_where the data to be processed is located.
However, like the machine language, the statement or instruction in the assembly language will vary from machine to another because the language is directly related to the internal architecture of the computer and is not designed to be machine independent. This makes the code written in assembly language less portable as the code written for one machine will not run on machines from a different or sometimes even the same manufacturer.

3. Third Generation
A third generation programming language (3GL) is a refinement of the second-generation programming language. The 2GL languages brought logical structure, to software. The third generation was introduced to make the languages more programmer friendly.
3GLs spurred the great increase in data processing that occurred in the 1960s and 1970s. In these languages, the program statements are not closely related to the internal characteristics of the computer and is therefore often referred to as high-level language.
translator is needed to translate the instructions written in high-level language into computer-executable machine language. Such translators are commonly known as interpreters and compilers. Each high level language has many compilers.
For example, the machine language generated by one computer's C compiler is not the same as the machine language of some other computer. Therefore, it is necessary to have a C compiler for each type of computer on which the C program has to be executed.
3GLs make it easier to write and debug a program and gives the programmer more time to think about its overall logic. The programs written in such languages are portable between machines. For example, a program written in standard C can be compiled and executed on any computer that has a standard C compiler.

4. Fourth Generation
With each generation, programming languages started becoming easier to use and more like natural languages. However, 4GLs is a little different from its prior generation because they are basically non-procedural. When writing code using a procedural language, the programmer has to tell the computer how a task is done-add this, compare that, do this if the condition is true, and so on, in a very specific step-by-step manner. In striking contrast, while using a non-procedural language the programmers define only what they want the computer to do, without supplying all the details of how it has to be done
There is no standard rule that defines what a fourth- generation language is but certain characteristics of such language include:
a.the code comprising instructions are written in English-like sentences;
b.they are non-procedural, so users concentrate on 'what' instead of the 'how' aspect of the task;
c.the code is easier to maintain;
4GL code enhances the productivity of the programmers as they have to type fewer lines of code to get something done. It is said that a programmer becomes 10 times more productive when he writes the code using a 4GL than using a 3GL.

5. Fifth Generation
5GLs are centred on solving problems using constraints given to the program, rather than using an algorithm written by a programmer. Most constraint-based and logic programming languages and some declarative languages form a part of the fifth-generation languages. 5GLs are widely used in artificial intelligence research. Typical examples of a 5GL include Prolog, OPS5, and Mercury.
Another aspect of a 5GL is that it contains visual tools to help develop a program. A good example of a fifth generation language is Visual Basic.